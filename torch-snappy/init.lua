local ffi = require 'ffi'

ffi.cdef([==[
/*
 * Return values; see the documentation for each function to know
 * what each can return.
 */
typedef enum {
  SNAPPY_OK = 0,
  SNAPPY_INVALID_INPUT = 1,
  SNAPPY_BUFFER_TOO_SMALL = 2
} snappy_status;

/*
 * Takes the data stored in "input[0..input_length-1]" and stores
 * it in the array pointed to by "compressed".
 *
 * <compressed_length> signals the space available in "compressed".
 * If it is not at least equal to "snappy_max_compressed_length(input_length)",
 * SNAPPY_BUFFER_TOO_SMALL is returned. After successful compression,
 * <compressed_length> contains the true length of the compressed output,
 * and SNAPPY_OK is returned.
 *
 * Example:
 *   size_t output_length = snappy_max_compressed_length(input_length);
 *   char* output = (char*)malloc(output_length);
 *   if (snappy_compress(input, input_length, output, &output_length)
 *       == SNAPPY_OK) {
 *     ... Process(output, output_length) ...
 *   }
 *   free(output);
 */
snappy_status snappy_compress(const char* input,
                              size_t input_length,
                              char* compressed,
                              size_t* compressed_length);

/*
 * Given data in "compressed[0..compressed_length-1]" generated by
 * calling the snappy_compress routine, this routine stores
 * the uncompressed data to
 *   uncompressed[0..uncompressed_length-1].
 * Returns failure (a value not equal to SNAPPY_OK) if the message
 * is corrupted and could not be decrypted.
 *
 * <uncompressed_length> signals the space available in "uncompressed".
 * If it is not at least equal to the value returned by
 * snappy_uncompressed_length for this stream, SNAPPY_BUFFER_TOO_SMALL
 * is returned. After successful decompression, <uncompressed_length>
 * contains the true length of the decompressed output.
 *
 * Example:
 *   size_t output_length;
 *   if (snappy_uncompressed_length(input, input_length, &output_length)
 *       != SNAPPY_OK) {
 *     ... fail ...
 *   }
 *   char* output = (char*)malloc(output_length);
 *   if (snappy_uncompress(input, input_length, output, &output_length)
 *       == SNAPPY_OK) {
 *     ... Process(output, output_length) ...
 *   }
 *   free(output);
 */
snappy_status snappy_uncompress(const char* compressed,
                                size_t compressed_length,
                                char* uncompressed,
                                size_t* uncompressed_length);

/*
 * Returns the maximal size of the compressed representation of
 * input data that is "source_length" bytes in length.
 */
size_t snappy_max_compressed_length(size_t source_length);

/*
 * REQUIRES: "compressed[]" was produced by snappy_compress()
 * Returns SNAPPY_OK and stores the length of the uncompressed data in
 * *result normally. Returns SNAPPY_INVALID_INPUT on parsing error.
 * This operation takes O(1) time.
 */
snappy_status snappy_uncompressed_length(const char* compressed,
                                         size_t compressed_length,
                                         size_t* result);

/*
 * Check if the contents of "compressed[]" can be uncompressed successfully.
 * Does not return the uncompressed data; if so, returns SNAPPY_OK,
 * or if not, returns SNAPPY_INVALID_INPUT.
 * Takes time proportional to compressed_length, but is usually at least a
 * factor of four faster than actual decompression.
 */
snappy_status snappy_validate_compressed_buffer(const char* compressed,
                                                size_t compressed_length);
]==])

local lib = ffi.load("snappy")

local snappy = {}

local function data_size(tensor)
  local bytes_per_element = ffi.sizeof(string.match(tostring(ffi.typeof(tensor:data())), "<(.*)%*")) or 0
  return bytes_per_element * tensor:nElement()
end

local byte_ptr = ffi.typeof("unsigned char *")

--[[ Compress a Tensor, returns a ByteStorage
`tensor` can be any torch Tensor type. Must be contiguous.
]]
function snappy.compress(tensor)
  assert(tensor:isContiguous(), "torch-snappy can only compress contiguous tensors")
  local tensor_data_size = data_size(tensor)
  local output_length = lib.snappy_max_compressed_length(tensor_data_size);
  local temp = torch.ByteStorage(tonumber(output_length))
  local buffer = temp:data()

  local compressed_size = ffi.new("size_t[1]", output_length)
  local result = lib.snappy_compress(ffi.cast(byte_ptr, tensor:data()), tensor_data_size, buffer, compressed_size)
  local compressed_data
  if result == lib.SNAPPY_OK then
    compressed_data = torch.ByteStorage(tonumber(compressed_size[0]))
    ffi.copy(compressed_data:data(), buffer, compressed_size[0])
  else
    error("torch-snappy couldn't compress your tensor :(")
  end

  local tensor_size = tensor:size()
  local tensor_new_f = tensor.new
  local function decompress_closure()
    local new_tensor = tensor_new_f():resize(tensor_size)
    return snappy.decompress(compressed_data, new_tensor)
  end

  return compressed_data, decompress_closure
end


--[[ Decompress a Tensor from a ByteStorage, into a given Tensor.
    `tensor` can be any torch Tensor type, but must be contiguous and have the
    correct number of elements.
]]
function snappy.decompress(bytes, tensor)
  assert(bytes, "snappy.decompress needs bytes")
  assert(tensor, "snappy.decompress needs dest tensor")
  assert(tensor:isContiguous(), "snappy.decompress needs dest tensor to be contiguous")

  local decompressed_size = ffi.new("size_t[1]", 0)
  local result = lib.snappy_uncompressed_length(bytes:data(),
                                                bytes:size(),
                                                decompressed_size)
  if result ~= lib.SNAPPY_OK then
    error("torch-snappy couldn't validate your compressed tensor :(")
  end

  if data_size(tensor) ~= decompressed_size[0] then
    error("target tensor num bytes doesn't match decompressed num bytes: "
          ..data_size(tensor).." != "..tonumber(decompressed_size[0]))
  end

  result = lib.snappy_uncompress(
      bytes:data(),
      bytes:size(),
      ffi.cast(byte_ptr, tensor:data()),
      decompressed_size
  )

  if result ~= lib.SNAPPY_OK then
    error("torch-snappy couldn't decompress your tensor :(")
  end

  return tensor
end

return snappy
